# [Bronze II] 알파벳 찾기 - 10809 

[문제 링크](https://www.acmicpc.net/problem/10809)  <br>

#### [1. 성능 요약](#성능-요약)
#### [2. 문제 설명](#문제-설명)
#### [3. 내 코드](#내-코드)
#### [4. 사용된 자료구조](#사용된-자료구조)

<hr>

### 성능 요약

메모리: 18292 KB, 시간: 184 ms

### 분류

구현, 문자열

### 제출 일자

2025년 10월 2일 09:25:15

### 문제 설명

<p>알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.</p>

### 출력 

 <p>각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.</p>

<p>만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.</p>


<br>
<br>

### 내 코드
````
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		int[] arr = new int[26]; //알파벳
		
		//모든 값을 -1로 초기화
		for(int i = 0; i < 26; i++) {
			arr[i] = -1; 
		}
		
		for(int i = 0; i< s.length(); i++) {
			char c = s.charAt(i); //i번째 문자
			int idx = c - 'a'; //'a'를 0으로, 'b'를 1로,.... 매핑
			if(arr[idx] == -1) { //처음 등장하는 위치 찾아야 하므로 -1일 때 해당 알파벳 첫 등장 인덱스 저장
				arr[idx] = i;
			}
		}
		
		//알파벳 숫서대로 첫 등장 인덱스 출력
		for(int i = 0; i < 26; i++) {
			System.out.print(arr[i] + " ");
		}
	} 
}
````
알파벳 개수는 고정이라 고정 크기 배열을 사용.<br>
초기화 값을 -1로 하는데, 만약 0으로 초기화하면 문자열에서 실제로 0번 위치에 등장한 알파벳과 구분이 불가능하다. 그러므로 -1과 같은 불가능한 값을 쓰는 게 안전하다.<br>
a 유니코드 값 97, b는 98, c는 99, ....<br>
그러므로 인덱스 맞추기 위해 ``int idx = c - 'a';`` <br>
``if (arr[idx] == -1) arr[idx] = i;`` **첫 등장 위치**만 요구하며, 이미 값이 기록됐으면(!= -1) 그보다 뒤에 나오는 같은 알파벳은 무시한다.
<br><br><br>

### 📌사용된 자료구조
배열 (Array)
````
int[] arr = new int[26];
````
알파벳 개수는 변하지 않기 때문에 크기가 고정되므로 배열 사용.﻿<br>
배열의 시간복잡도 : O(1)﻿. 상수 시간이므로 바로 접근이 가능하다.

<br>
<br>
<br>
<br>
<br>
